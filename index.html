<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haywire Moving Head Finder</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/lucide-react@latest"></script>

    <style>
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-900">
    <div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // Sicherheits-Check für Icons:
    // Falls LucideReact nicht korrekt geladen wird, nutzen wir Platzhalter
    const icons = window.LucideReact || {};
    const Aperture = icons.Aperture || (() => <span>⭕</span>);
    const Edit2 = icons.Edit2 || (() => <span>📝</span>);
    const Search = icons.Search || (() => <span>🔍</span>);
    const AlertTriangle = icons.AlertTriangle || (() => <span>⚠️</span>);

        // --- Konfigurationsdaten (wie in deinem Original) ---
        const INITIAL_TYPE_OPTIONS = ["Viper Performance", "Viper Wash DX", "Impression X5", "Diablo S", "Impression FR10 Bar", "Impression X4 Bar", "JDC 1"];
        const INITIAL_POSITION_OPTIONS = ["Z-Brücke 1", "Sound Truss SR", "Sound Truss SRC", "Sound Truss SLC", "Sound Truss SL", "LX 1", "LX 2", "LX 3", "LX 4", "LX 5", "Near Box Boom SR", "Near Box Boom SL", "Advanced Truss SR", "Advanced Truss SL", "Prosc Boom SR", "Prosc Boom SL", "DS Trough", "Leiter 1 SR", "Leiter 2 SR", "Leiter 3 SR", "Leiter 4 SR", "Leiter 1 SL", "Leiter 2 SL", "Leiter 3 SL", "Leiter 4 SL", "Boom 1 SR", "Boom 2 SR", "Boom 3 SR", "Boom 4 SR", "Boom 1 SL", "Boom 2 SL", "Boom 3 SL", "Boom 4 SL", "Portal"];
        const ORT_OPTIONS = ["Dimmerraum 1", "Dimmerraum 2", "Dimmerraum 3", "Dimmerraum 4"];

        // --- Hilfskomponenten ---
        const SelectField = ({ label, value, options, onChange, warning }) => (
            <div className="mb-4">
                <label className="block text-xs font-semibold text-slate-400 uppercase tracking-wide mb-1 flex justify-between">
                    {label}
                    {warning && <span className="text-yellow-500 flex items-center gap-1 text-[10px]"><AlertTriangle size={10} /> Neuer Wert</span>}
                </label>
                <div className="relative">
                    <select 
                        value={value} 
                        onChange={(e) => onChange(e.target.value)}
                        className={`block w-full appearance-none bg-slate-800 border text-white py-3 px-4 pr-8 rounded leading-tight focus:outline-none focus:border-blue-500 focus:bg-slate-700 transition-colors ${warning ? 'border-yellow-500/50' : 'border-slate-600'}`}
                    >
                        <option value="">Bitte wählen...</option>
                        {options.map(opt => <option key={opt} value={opt}>{opt}</option>)}
                    </select>
                </div>
            </div>
        );

        const InputField = ({ label, value, onChange, type = "text" }) => (
            <div className="mb-4">
                <label className="block text-xs font-semibold text-slate-400 uppercase tracking-wide mb-1">{label}</label>
                <input 
                    type={type}
                    value={value} 
                    onChange={(e) => onChange(e.target.value)}
                    className="block w-full bg-slate-800 border border-slate-600 text-white py-3 px-4 rounded leading-tight focus:outline-none focus:border-blue-500 focus:bg-slate-700 transition-colors"
                />
            </div>
        );

        // --- Hauptkomponente ---
        function App() {
            const [fixtures, setFixtures] = useState(() => {
                const saved = localStorage.getItem('fixtureData');
                return saved ? JSON.parse(saved) : [];
            });
            const [typeOptions, setTypeOptions] = useState(INITIAL_TYPE_OPTIONS);
            const [positionOptions, setPositionOptions] = useState(INITIAL_POSITION_OPTIONS);
            const [searchTerm, setSearchTerm] = useState("");
            const [activeFilter, setActiveFilter] = useState("Alle");
            const [editId, setEditId] = useState(null);
            const [editForm, setEditForm] = useState({});
            const [isLoading, setIsLoading] = useState(false);

            const cleanValue = (val) => val ? val.toString().trim() : "";

            const processCSVData = (data) => {
                const newTypes = new Set(INITIAL_TYPE_OPTIONS);
                const newPositions = new Set(INITIAL_POSITION_OPTIONS);
                const parsedData = data.map((row, index) => {
                    let typ = cleanValue(row.TYP || row.Typ || "");
                    let pos = cleanValue(row.POSITION || row.Position || "");
                    if (typ === "Impression X 5") typ = "Impression X5";
                    if (pos === "LX1") pos = "LX 1"; 
                    if (typ && !INITIAL_TYPE_OPTIONS.includes(typ)) newTypes.add(typ);
                    if (pos && !INITIAL_POSITION_OPTIONS.includes(pos)) newPositions.add(pos);
                    return {
                        id: Date.now() + index,
                        CHANNEL: cleanValue(row.CHANNEL || row.Channel || ""),
                        TYP: typ, POSITION: pos, ORT: cleanValue(row.ORT || row.Ort || ""), ADRESSE: cleanValue(row.ADRESSE || row.Adresse || "")
                    };
                });
                setTypeOptions(Array.from(newTypes).sort());
                setPositionOptions(Array.from(newPositions).sort());
                setFixtures(parsedData);
            };

            useEffect(() => {
                const fetchCSV = () => {
                    setIsLoading(true);
                    if (window.Papa) {
                        window.Papa.parse("fixtures.csv", {
                            download: true,
                            header: true,
                            skipEmptyLines: true,
                            complete: (results) => {
                                if (results.data && results.data.length > 0) processCSVData(results.data);
                                setIsLoading(false);
                            },
                            error: () => setIsLoading(false)
                        });
                    }
                };

                if (!window.Papa) {
                    const script = document.createElement('script');
                    script.src = "https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js";
                    script.onload = fetchCSV;
                    document.body.appendChild(script);
                } else { fetchCSV(); }
            }, []);

            useEffect(() => { localStorage.setItem('fixtureData', JSON.stringify(fixtures)); }, [fixtures]);

            const startEditing = (f) => { setEditId(f.id); setEditForm({...f}); };
            const saveEdit = () => { setFixtures(prev => prev.map(f => f.id === editId ? editForm : f)); setEditId(null); };
            const deleteFixture = (id) => { if(confirm("Löschen?")) setFixtures(prev => prev.filter(f => f.id !== id)); };

            const availablePositions = useMemo(() => {
                const fromData = new Set(fixtures.map(f => f.POSITION).filter(p => p));
                INITIAL_POSITION_OPTIONS.forEach(p => fromData.delete(p));
                return ["Alle", ...INITIAL_POSITION_OPTIONS, ...Array.from(fromData).sort()];
            }, [fixtures]);

            const filteredFixtures = useMemo(() => {
                return fixtures.filter(f => {
                    const matchesSearch = (f.CHANNEL?.toLowerCase().includes(searchTerm.toLowerCase()) || f.TYP?.toLowerCase().includes(searchTerm.toLowerCase()));
                    const matchesFilter = activeFilter === "Alle" || f.POSITION === activeFilter;
                    return matchesSearch && matchesFilter;
                });
            }, [fixtures, searchTerm, activeFilter]);

            return (
                <div className="w-full min-h-screen bg-slate-900 text-slate-200 pb-24 font-sans">
                    <div className="sticky top-0 z-20 bg-slate-900/95 p-4 border-b border-slate-800 shadow-lg flex flex-col gap-4">
                        <h1 className="text-2xl font-bold text-white flex items-center gap-3">
                            <Aperture className="text-yellow-500" size={28} /> Finder
                        </h1>
                        <input 
                            className="w-full bg-slate-800 p-2 rounded border border-slate-700 text-white" 
                            placeholder="Suchen..." 
                            onChange={e => setSearchTerm(e.target.value)} 
                        />
                        <div className="flex gap-2 overflow-x-auto scrollbar-hide">
                            {availablePositions.map(pos => (
                                <button key={pos} onClick={() => setActiveFilter(pos)} className={`px-3 py-1 rounded-full text-xs ${activeFilter === pos ? 'bg-blue-600 text-white' : 'bg-slate-800 text-slate-400'}`}>
                                    {pos}
                                </button>
                            ))}
                        </div>
                    </div>

                    <div className="p-4 space-y-4 max-w-md mx-auto">
                        {filteredFixtures.map(fixture => (
                            <div key={fixture.id} className="bg-slate-800 p-4 rounded-xl border border-slate-700">
                                {editId !== fixture.id ? (
                                    <div onClick={() => startEditing(fixture)}>
                                        <div className="flex justify-between">
                                            <span className="bg-blue-600 px-2 rounded font-mono font-bold">{fixture.CHANNEL}</span>
                                            <Edit2 size={16} className="text-slate-500" />
                                        </div>
                                        <div className="font-bold mt-2">{fixture.TYP}</div>
                                        <div className="text-xs text-slate-400">{fixture.POSITION} | {fixture.ORT}</div>
                                    </div>
                                ) : (
                                    <div>
                                        <InputField label="Channel" value={editForm.CHANNEL} onChange={v => setEditForm({...editForm, CHANNEL: v})} />
                                        <div className="flex gap-2">
                                            <button onClick={saveEdit} className="bg-blue-600 flex-1 p-2 rounded">Speichern</button>
                                            <button onClick={() => setEditId(null)} className="bg-slate-700 flex-1 p-2 rounded">X</button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>
